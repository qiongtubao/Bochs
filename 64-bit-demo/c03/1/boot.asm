;/***************************************************
;		版权声明
;
;	本操作系统名为：MINE
;	该操作系统未经授权不得以盈利或非盈利为目的进行开发，
;	只允许个人学习以及公开交流使用
;
;	代码最终所有权及解释权归田宇所有；
;
;	本模块作者：	田宇
;	EMail:		345538255@qq.com
;
;
;***************************************************/
    
	org	0x7c00	;org 指令告诉汇编器这个程序应该从偏移量 0x7C00 开始。对于引导扇区来说，这是非常典型的，因为BIOS会将第一个扇区读入内存地址 0x0000:0x7C00 并跳转到那里执行。

BaseOfStack	equ	0x7c00 ;equ 指令定义了一个常量。这里 BaseOfStack 被设置为 0x7C00，这表示栈顶的位置。然而，在实模式下，通常栈底会设置在内存的较低位置，而栈顶则会在较高的位置。因此，通常我们会把栈指针（SP）设为一个比代码起始地址更高的值，以便向下生长。


Label_Start: ;这是一个标签，它用来标记代码中的位置，可以作为跳转的目标或参考点。

	mov	ax,	cs   		;CS寄存器包含当前执行代码所在的段的选择子。当CPU需要从内存中获取指令时，它会使用CS寄存器中的值加上指令指针（IP或EIP）来计算出实际的内存地址。这个组合构成了程序中下一条要执行的指令的地址。
	mov	ds,	ax	 		;DS寄存器指向程序的数据段，其中包含了全局变量、静态变量等数据。当程序访问这些数据时，通常会使用DS寄存器作为基地址来计算实际的内存地址。
	mov	es,	ax	 		;ES是一个额外的段寄存器，主要用于字符串操作指令（如movs, stos等）。它允许程序将数据写入到不同于默认数据段的位置。
	mov	ss,	ax   		;SS寄存器包含堆栈段的选择子。堆栈是用于函数调用、中断处理、局部变量存储等的一种特殊的内存区域。SP（Stack Pointer）或ESP（Extended Stack Pointer）寄存器用来指示堆栈顶部的当前位置。每次函数调用或者压栈/弹栈操作发生时，SP/ESP都会相应地调整以反映新的堆栈顶位置。
	mov	sp,	BaseOfStack ;SP寄存器（在16位模式下）或者ESP寄存器（在32位模式下）是栈指针寄存器，它总是指向当前堆栈顶端。在进行函数调用时，返回地址会被推入堆栈，此时SP/ESP会减小（因为堆栈向下增长）。当函数返回时，返回地址被弹出堆栈，SP/ESP又会增大。此外，局部变量也通常通过调整SP/ESP来分配空间。

;=======	clear screen  ;因此，这段代码的效果是将屏幕上的一个窗口（几乎整个屏幕，从第0行第0列到第24行第79列）清除，并且使用灰色前景色和黑色背景色来显示任何新的文本。光标位置不会改变，因为它是由AX寄存器中的低字节00决定的。

	mov	ax,	0600h	;功能号06表示要执行“清除并更新窗口”操作。低字节为00表示不移动光标。
	mov	bx,	0700h	;表示使用的属性（颜色）。在这里，高字节07定义了默认的颜色属性（灰色前景色，黑色背景色），低字节为00通常无意义，在这个功能中被忽略。
	mov	cx,	0		;定义了窗口的左上角坐标（行:列），这里CX=0即0000h表示从屏幕的第0行第0列开始。
	mov	dx,	0184fh	;定义了窗口的右下角坐标（行:列），这里DX=0184fh表示窗口的右下角在第24行（因为高位字节018h=24）第79列（低位字节4fh=79），即几乎整个屏幕。
	int	10h			;这是调用BIOS中断服务程序，以执行由AH寄存器（这里是AX的高字节，但在这个例子中，我们关注的是整个AX寄存器）指定的功能。

;=======	set focus

	mov	ax,	0200h	;功能号02表示要执行“设置光标位置”操作。低字节为00在这个功能中没有特定含义。
	mov	bx,	0000h	;定义了显示页号。在大多数文本模式下，只有一个显示页（即页号0），所以这里设置为0000h。
	mov	dx,	0000h	;定义了光标的新位置。DX寄存器的高字节定义行号，低字节定义列号。这里DX=0000h意味着将光标移动到屏幕的第0行第0列
	int	10h			;这是调用BIOS中断服务程序，以执行由AH寄存器（这里是AX的高字节）指定的功能。

;=======	display on screen : Start Booting......

	mov	ax,	1301h	;功能号13表示要执行“写字符串”操作。高字节13h是功能号，低字节01h表示光标跟随字符串之后移动。
	mov	bx,	000fh	;定义了字符属性（颜色）。这里000fh意味着黑色背景色（高位字节00）和亮白色前景色（低位字节0f）。
	mov	dx,	0000h	;定义了屏幕上的起始位置。DX寄存器的高字节定义行号，低字节定义列号。这里DX=0000h意味着从屏幕的第0行第0列开始显示字符串。 “Start Boot” 10个字符串
	mov	cx,	10		;表示要显示的字符数量。这里是十进制的10，即显示10个字符。
	push	ax		;
	mov	ax,	ds		;将数据段寄存器（DS）的值复制到额外段寄存器（ES），这是为了确保源字符串的地址计算正确
	mov	es,	ax		;ES:BP指向要显示的字符串。
	pop	ax
	mov	bp,	StartBootMessage	;将StartBootMessage的偏移地址加载到基址指针（BP）寄存器中。StartBootMessage应该是指向你想要显示的字符串的标签或地址。
	int	10h			;调用BIOS中断服务程序，根据设置的参数显示字符串。

;=======	reset floppy

	xor	ah,	ah	;将AH寄存器清零。在BIOS中断13h中，功能号00h表示重置磁盘系统（通常是软盘驱动器）。清除AH寄存器相当于设置它为00h，即选择了重置磁盘系统的功能。
	xor	dl,	dl	;将DL寄存器清零。DL寄存器在这里指定要操作的驱动器编号。00h通常代表第一个软盘驱动器（A:）。如果想要操作其他驱动器，则需要将DL设置为相应的值（例如，80h表示第一个硬盘）。
	int	13h		;调用BIOS磁盘服务中断。根据前面设置的功能号和参数，这里执行的是“重置磁盘系统”命令。这个命令会初始化磁盘控制器，并准备好进行后续的读写操作。如果操作成功，CF（进位标志）会被清除；如果失败，CF会被设置，且AH寄存器中会包含错误代码。

	jmp	$		;这是一个无限循环指令。$符号表示当前指令的地址，因此这条指令会让程序跳转到自身，造成无限循环。这通常用于在完成某些任务后停止程序的执行，防止它继续运行并可能破坏数据或系统状态。在这种情况下，一旦磁盘重置命令被执行，程序就会陷入这个无限循环中，等待外部干预或重启。

StartBootMessage:	db	"Start Boot"	;定义一个以NULL结尾的字符串"Start Boot"。

;=======	fill zero until whole sector

	times	510 - ($ - $$)	db	0
	dw	0xaa55